/**
 * programmed by Hungsik Kim
 * 1. Find key frames based on HSV histogram difference curvature (dynamic key frames)
 *
 */
import java.io.*;
import DataStructure.VideoKeyFrameStep1;

public class FindKeyFrame {
    
    int[] corner;
    int[] cornerCandidate;
    final double angleThrs=3; // threshold to find corner
    final int windowSize = 3; // window size to compute maximum angle
    final double scaleFactor = 5.0;
    long[] keyFrame;
    
    public void findKey(double[] sum) {
    	double[] minAngle = new double[sum.length];
    	minAngle[0]=0; minAngle[sum.length-1]=0; // set the first frame and last frame is corner.
    	double[] angle = new double[windowSize*windowSize];    	
    	int temp=0;
    	for(int i=1; i<sum.length-1; i++){
    		initAngle(angle);
    		int m=i-1; // index for left side of a point i
    		int n=i+1; // index for right side of a point i
    		int iAngle=0;
    		while(m>=0 && i-m<=windowSize){
    			while(n<sum.length && n-i<=windowSize){
    				angle[iAngle] = Math.acos((Math.pow(dist(sum[i]-sum[m],(double)i-m),2.0)
    					+Math.pow(dist(sum[i]-sum[n],(double)n-i),2.0)
    						-Math.pow(dist(sum[m]-sum[n],(double)n-m),2.0))
    							/(2.0*dist(sum[i]-sum[m],(double)i-m)*dist(sum[i]-sum[n],(double)n-i)));
	    			n++;
	    			iAngle++;
    			}
    			n=i+1;
    			m--;
    		}
    		minAngle[i]=min(angle);
    	}
    	findCorner(minAngle,angleThrs);
    	keyFrame = new long[corner.length-1];
    	for(int i=1;i<corner.length;i++){
    		keyFrame[i-1]=(corner[i]+corner[i-1])/2;
    	}
    	for(int i=0;i<keyFrame.length;i++){
    		System.out.println("keyFrame["+i+"]="+keyFrame[i]);
    	}    	
    }
    public void findCorner(double[] minAngle, double angleThrs){
    	int numberOfMin=0;
    	int temp=0;
    	for(int i=0;i<minAngle.length;i++){
    		if(minAngle[i]<angleThrs) numberOfMin++;
    	}
    	cornerCandidate = new int[numberOfMin];
    	int k=1;
    	for(int i=1;i<minAngle.length;i++){
    		if(minAngle[i]<angleThrs){    			
    			if (i-cornerCandidate[k-1]<windowSize){    				
    				if(minAngle[cornerCandidate[k-1]]>minAngle[i]){
    					cornerCandidate[k-1]=i;    					
    				}    				
    			}
    			else{
    				cornerCandidate[k]=i;    	
    				k++;
    			}    			
    		}
    	}    	
    	corner = new int[k];
    	System.arraycopy(cornerCandidate,0,corner,0,k);
    	
    	for(int i=0;i<k;i++){
    		System.out.println("corner["+i+"]="+corner[i]);
    	}
    }
    public double min(double[] angle){
    	double minValue=Math.PI;
    	for(int i=0;i<angle.length;i++){
    		if(minValue>angle[i]) minValue = angle[i];
    	}
    	return minValue;
    }
    public double dist(double a, double b){
    	return Math.pow(a*a+b*b, 0.5);
    }
    public void initAngle(double[] angle){
    	for(int i=0;i<angle.length;i++) angle[i]=Math.PI;
    }
    
    public void scaleDifference(double[] difference, double scaleFactor){
    	for(int i=0; i<difference.length; i++){
    		difference[i]=difference[i]*scaleFactor;
    	}
    }    	
     
    public static void main(String[] args) throws IOException, ClassNotFoundException {
    	// read object generated by step 1
    	ObjectInputStream ois = new ObjectInputStream(new FileInputStream(args[0]));
    	VideoKeyFrameStep1 ob1 = (VideoKeyFrameStep1)ois.readObject();
    	ois.close();
    	// generate Gaussian filter (The length of Gaussian filter is 7)
    	GaussianFilter gFilter = new GaussianFilter(1,4);
    	FindKeyFrame findKeyFrame = new FindKeyFrame();	

    	int j=0;    	
    	// find key frames for all shots in a video    	
    	while(ob1.shot[j]!=null){
    		System.out.println("\n\nShot Number: " + j + "   ::  First Frame : " + ob1.shot[j].firstFrame);
    		// the first frame is a key frame, no Gaussian filter is applied.
    		if(ob1.shot[j].difference==null){
    			ob1.shot[j].keyFrame = new long[1];
    			ob1.shot[j].keyFrame[0] =ob1.shot[j].firstFrame;
    			break;
    		}
    		// if the number of frames in a shot is less than 7, no Gaussian filter is applied
    		if(ob1.shot[j].difference.length<4){
    			ob1.shot[j].keyFrame = new long[1];
    			ob1.shot[j].keyFrame[0] =ob1.shot[j].firstFrame;
    			break;
    		}    	
    		double[] sum= new double[ob1.shot[j].difference.length]; // sum contains coefs after GF
    		// apply scaling factor
    		findKeyFrame.scaleDifference(ob1.shot[j].difference,findKeyFrame.scaleFactor);
    		// apply Gaussian filter
    		gFilter.conv(sum,ob1.shot[j].difference,gFilter.g);    		

	    	System.out.println("Find Key Frame");
	    	// find key frames
	    	findKeyFrame.findKey(sum);
	    	ob1.shot[j].keyFrame=findKeyFrame.keyFrame;
	    	for(int i=0;i<ob1.shot[j].keyFrame.length;i++){
    			ob1.shot[j].keyFrame[i]=ob1.shot[j].keyFrame[i]+ob1.shot[j].firstFrame;
    		}
	    	System.out.println();
	    	System.out.println(" New key frames");
	    	for(int i=0;i<ob1.shot[j].keyFrame.length;i++){
    			System.out.println("Shot Number: " + j + "   ::  key Frame : " + ob1.shot[j].keyFrame[i]);
    		}
    		j++;
    	}
    	try{
    		// write intermediate data to pass to step 2
    		String outputName = args[0].replace("diff", "keyframe");
			ObjectOutputStream oos = 
					new ObjectOutputStream(new FileOutputStream(outputName));			    		
			oos.writeObject(ob1);
			oos.close();
			System.exit(0);
		}catch(Exception e){System.out.println("Cannot write files : " +e);}
    }
}
